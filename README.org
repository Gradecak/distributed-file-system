* Table of Contents                                :TOC:
 - [[#distributed-filesystem-dfs][Distributed FileSystem (DFS)]]
   - [[#dfs-services][DFS Services:]]
     - [[#authentication-service][Authentication Service:]]
       - [[#service-overview][Service Overview:]]
       - [[#message-encryption][Message Encryption:]]
       - [[#user-authentication][User Authentication:]]
       - [[#internal-authentication][Internal Authentication]]
     - [[#directory-service][Directory Service:]]
       - [[#service-overview-1][Service Overview:]]
         - [[#api][API:]]
       - [[#filepath-to-fileserver-mapping][FilePath to FileServer mapping]]
       - [[#creating-new-files][Creating New Files]]
       - [[#deleting-files][Deleting Files]]
     - [[#transactionlocking-service][Transaction/Locking service]]
       - [[#service-overview-2][Service Overview]]
       - [[#locking][Locking]]

* Distributed FileSystem (DFS)
** DFS Services:
   - Authentication Service
   - Directory Service
   - Transaction/Locking Service
   - File Service
   - Client Library (Proxy)

*** Authentication Service:
**** Service Overview:
     The Authentication service is the main authority in the DFS it handles
     client authentication, inter-service authentication and system state
     tracking (i.e. fileserver locations, directory server location etc..). All
     services on startup must report to the Authentication Service before they
     are officially integrated into the DFS
**** Message Encryption:
     The Distributed File System has no bespoke message encryption scheme.
     Instead, the services of the DFS are meant to be run behind a reverse proxy
     (Such as Apache, Nginx etc..). In a production system these reverse proxies
     would guarantee message encryption via TLS. This is standard practice in
     many REST applications as these web servers are made for this purpose and
     are more resilient to many types or errors and attacks.
**** User Authentication:
     The Authentication service stores a list of Usernames and Password Hashes
     in a key/value store Redis. A user wishing to use the DFS must first
     authenticate themselves with the DFS before they can gain access to the
     system. To authenticate themselves the user will send their username +
     password hash and the Authentication Service will perform a lookup in the
     key/value store for matching details. If authentication is successful, the
     user will be issued with a UUID (Universal Unique Identifier)[Token] and
     the IP addresses of the Directory and Transaction Services. The token will
     be set to expire after a number of minutes. As well as issuing the Token to
     the User, the Authentication service will also broadcast the token to all
     of the other services. The other services will place the token in their
     Redis instance, setting the expiry time to that specified by the Token
     (expiry is provided by Redis as expired tokens will be automatically
     deleted). A user wishing to access any other service from then on must
     present their token as a HTTP header (auth-cookie). Each service will then
     do a lookup on receiving a request in their Redis instance and only valid
     Token holders will be granted access.
**** Internal Authentication
     Different Services within the DFS must also be able to verify each others
     identities to ensure that no foreign or malicious service is attempting to
     access the system. As such, when a service (such as Directory or
     Transaction) is first started. They register themselves with the
     Authentication service. The Authentication service issues to them
     information about all of the other services currently in the system (if
     needed) and also provides them with an Internal Session token. Similar to
     the client authentication, internal services wishing to communicate to
     other services via an internally protected endpoint must include the
     internal token in their request header before their messages will be
     considered authentic.

*** Directory Service:
**** Service Overview:
     The Directory service is responsible for mapping human readable file-paths
     to fileservers and file ID's. As well as this, the directory service is
     charged with creation/deletion of files and allocating which fileservers the
     files are to be replicated on.
***** API:
      -Public Endpoints:

      /list : returns the contents of a directory

      -Private Endpoints:
      /ls   : same as /list but internal
      /open : resolve a filePath to a fileHandle (location on a fileserver)
      /mv   : move a src to destination
      /rm   : remove a file
**** FilePath to FileServer mapping
     The mapping of file-paths to file server is done through a 'shadow'
     filesystem. The Directory server makes use of the hosts filesystem in order
     to create a mapping between file-paths and the fileservers in which the
     file resides. When a new file is created the directory service selects the
     fileservers on which the file should be placed. This list of file locations
     (FileHandles) is then serialized and written to a file in the 'shadow'
     filesystem corresponding to the human readable file-path that the user
     provided.

     Similarly, when a user wishes to find out where a file is
     located, they provide a filepath which is looked up in the shadow
     file-system. The file that the path is pointing to is read in, giving us a
     list of FileHandles. the head of the list is returned, and is then moved to
     the end of the list, providing a sort of round-robin balancing of file
     access'. Recently accessed filepaths are cached in memory meaning that we
     can avoid expensive file access operations for frequently accessed files.
**** Creating New Files
     When creating a new file, the directory server first selects N file servers
     that the file should be duplicated on. Following this, file meta-data is
     generated (consisting of file-id, server location, version number etc) and
     disseminated to each of the selected fileservers. This is essentially
     'version 0' of the file. As well as generating file metadata the directory
     service also generates a list of FileHandles corresponding to which
     fileserver the file can be found on. The user who requested the new file is
     given a file handle which contains the IP and file-id of the requested
     file. Once they upload the file to the fileserver they were given, the file
     version is updated and the GOSSIP protocol ensures that all of the N chosen
     file servers get the new version.
**** Deleting Files
     Deleting files is simple, the user provides a filepath to the file they
     wish to remove. This file is located in the shadow file system and read in
     to memory, giving us a list of FileHandles (file meta-data). Each of the
     fileservers mentioned in the list of FileHandles is notified of the file
     deletion and instructed to delete their copy of the file. The directory
     service then simply removes the meta-data file from the shadow filesystem.
*** Transaction/Locking service
**** Service Overview
     The Transaction/Locking service is a Transaction service and a Locking
     service combined into one. It is responsible for locking/unlocking single
     files as well as providing transactions when more complicated operations
     such as directory moves are preformed.
**** Locking
     The locking service is implemented using a simple hash table. The hash
     table maps file paths to the status of the file (Locked/Unlocked). When a
     user wishes to access a file, the only way that they can find out what
     fileserver it resides on is for them to request to open the file from the
     Transaction/Locking service (The transaction service then resolves the
     filepath with the Directory service). The Transaction/Locking service looks up
     the status of the provided filepath, if its locked the client is served
     with
